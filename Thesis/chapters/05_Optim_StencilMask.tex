% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\section{HMD Stencil Mask} \label{stencilmask}
\subsection{Theory}
Introduced to the mass market with 3Dlabs' Permedia II in 1997 and widely adopted since then, all modern graphics chips support a nifty feature called the stencil buffer. This buffer uses low bit integer values - commonly 8 bits per pixel for a depth of 256 \textcolor{green}{[SRC: learnopengl.com/Advanced-OpenGL/Stencil-testing]} that can be read from and written to during the fragment stage, with stencil testing happening after alpha and before depth testing. Sometimes used for certain shadowing operations, the stencil buffer is primarily used for cheap masking efforts. \\
One such effort was presented by Alex Vlachos at GDC 2015 \textcolor{green}{[SRC: Valve talk]} as a possibility to improve performance in VR applications. Once again pointing at the significant areas of invisible screen space wasted outside the HMD lenses' warping reach, the idea here is to write into a per-eye pixel matched stencil buffer a mask corresponding to the shape of the visible screen area. Then during the fragment stage of a frame render, the stencil test can early discard all masked fragments and thus avoid pixel shader work for all these areas. The operation can essentially be imagined exactly as the classic idea of stencil mask when painting surfaces, where paint will only hit the surface within the cutouts of the stencil. Similarly the graphics chip will only write color and depth values to unmasked fragments. \\

\textcolor{red}{[TODO: illustration]}

\subsection{Estimated impact}
The performance gain then naturally scales well with both increased fragment shader bias of the per-frame workload as well as with the HMD's blind areas. Valve's Vlachos in his GDC talk showcased gains of 17\% lower GPU frametimes for the company's Aperture Labs VR showcase scene using an HTC Vive headset. \textcolor{green}{[SRC: Valve talk]}
Assuming a roughly uniform distribution of objects in the scene and accordingly a roughly constant shader workload during use, the relative improvement in fragment render time is directly proportional to the masked percentage of the total framebuffer. 

\textcolor{red}{[TODO]}

\subsection{Implementation specifics}
Outfitting Tachyon for stencil masking required the addition of the entire stencil stack as the engine did not use the feature in any capacity yet. An inherent advantage of this is that it allows to render the stencil mask only once at startup and keep reusing it every frame without additional render load for the mask. \\
The changes include extending the depth attachment of the OpenVR render pass with the \codeword{VK_IMAGE_ASPECT_STENCIL_BIT} so the additional buffer layer is created at startup. What's more, the involved Vulkan pipelines need stencil operation states defined in their \codeword{VkPipelineDepthStencilStateCreateInfo}, with the operations set as in \autoref{fig:lst_StencilOpState_MaterialPipeline} so the bits are checked against but not modified. Next, the VR render pass needs its color attachment's \codeword{stencilLoadOp} set to \codeword{VK_ATTACHMENT_LOAD_OP_LOAD} so the renderer knows to load the stencil buffer at the start of the color pass, and the \codeword{stencilStoreOp} to \codeword{VK_ATTACHMENT_STORE_OP_DONT_CARE} so it can leave the buffer behind after use without saving anything more to it. This is important to make sure our stencil buffer remains unmodified and expensive writes are avoided. 

\begin{figure}[htb]
  \centering
  \begin{tabular}{c}
  \begin{lstlisting}[language=C++]
	//stencil op settings for pipelines using 
	//the stencil mask for comparison 
	VkStencilOpState stencilOpState = {};
	stencilOpState.compareOp = VK_COMPARE_OP_NOT_EQUAL;
	stencilOpState.failOp = VK_STENCIL_OP_KEEP;
	stencilOpState.depthFailOp = VK_STENCIL_OP_KEEP;
	stencilOpState.passOp = VK_STENCIL_OP_KEEP;
	stencilOpState.compareMask = 0xff;
	stencilOpState.writeMask = 0xff;
	stencilOpState.reference = 1;
	\end{lstlisting}
  \end{tabular}
  \caption[Material pipeline stencil operation flags]{Stencil operation flags set for default material Pipeline}\label{fig:lst_StencilOpState_MaterialPipeline}
\end{figure}

Rendering the stencil mask itself at startup is done as follows: 
OpenVR by now has some helper functions for masking built in, such as the \codeword{GetHiddenAreaMesh(EVREye eEye)} function that returns as screenspace normalized list of vertices representing the ideal mask mesh for the current HMD as known to OpenVR \textcolor{red}{[TODO: check "ideal"ity for various HMDs]}. The obvious benefit of this is the simplicity of getting a fitted mask for most HMDs instead of either approximating with circular masks or going through the trouble of manually creating fitted meshes for existing and coming OpenVR-enabled headsets. Unfortunately, however, OpenVR in a few instances returns empty masks, such as for the Oculus Rift CV1. For those cases a fast circular approximation mask may be an adequate compromise. \\
Tachyon queries OpenVR for the mesh of each eye, converts the vertex lists into a renderer-compatible vertex format and writes out a vertex and index buffer each. 
At the end of the VR render pass, an ad-hoc command buffer is recorded and submitted to render the two masks into the VR framebuffer's depth attachment's stencil layer. The \codeword{VK_IMAGE_ASPECT_STENCIL_BIT} is set to ensure only that layer is written to. \\

Due to Vulkan's verbose nature, rendering these two masks also requires its own pipeline. The default material pipeline, PBR pipeline et cetera only do stencil test compares, no writes, they perform color writes and rasterizer face culling, all things the stencil mask pipeline should do differently. So a separate stencil pipeline is introduced with stencil operation state set like in \autoref{fig:lst_StencilOpState_StencilPipeline}, color writes masked off and rasterizer culling disabled. Should the need to perform per-frame stencil writes arise, merging the material pipelines and the stencil pipeline may prove beneficial to avoid expensive pipeline re-binds, but for the sake of cleaner separation the described setup was used in Tachyon's current implementation. 

\begin{figure}[htb]
  \centering
  \begin{tabular}{c}
  \begin{lstlisting}[language=C++]
	//stencil op settings for the stencil pipeline 
	VkStencilOpState stencilOpState = {};
	stencilOpState.compareOp = VK_COMPARE_OP_ALWAYS;
	stencilOpState.failOp = VK_STENCIL_OP_REPLACE;
	stencilOpState.depthFailOp = VK_STENCIL_OP_REPLACE;
	stencilOpState.passOp = VK_STENCIL_OP_REPLACE;
	stencilOpState.compareMask = 0xff; 
	stencilOpState.writeMask = 0xff;
	stencilOpState.reference = 1;
	\end{lstlisting}
  \end{tabular}
  \caption[Stencil pipeline stencil operation flags]{Stencil operation flags set for stencil mask Pipeline}\label{fig:lst_StencilOpState_StencilPipeline}
\end{figure}
