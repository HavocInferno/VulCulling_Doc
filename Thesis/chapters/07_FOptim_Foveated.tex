% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\section{Foveated Rendering}
This technique lends its name from the fovea centralis, a spot in the center of the primate retina, responsible for sharp central vision of the eye. The regions around it gradually lose visual sharpness as they contain fewer and fewer cone cells. 
Foveated rendering in its various forms builds on this limitation of the human photoreceptive system. For example, as described in the Oculus Go optimization guide by Palandri et al.\cite{Palandri.2018} the image produced by a \gls{VR} renderer is warped by the \gls{VR} compositor to closely match the spherical shape of the lenses and the distorted field of view they create. This warping means that toward the edge of the frame, more pixels are compressed into a given angle of vision than in the center, effectively leading to much higher pixel density for peripheral regions. Conversely, the peripheral vision of the human eye is usually significantly less sharp than the aforementioned foveal vision. Therefore the outer rim of the rendered image can be rendered at much lower pixel density without sacrificing a humanly noticeable amount of detail if the \gls{HMD} can even physically display this density. Exactly that is the concept of foveated rendering, it decreases resolution of the edge regions of the image while rendering the central area at full resolution. However, there is one big constraint. The foveal vision of the user and the artificial foveal center of the image need to match up, otherwise a user may easily notice the lowered pixel density. To accurately match these two focus points, the user's eye movements need to be tracked and the supposed focus center of the image adjusted accordingly. 

\subsection{Fixed versus True Foveated Rendering}
Eye tracking can be foregone in theory, assuming the headset's field of view is low enough to physically discourage a wide range of eye movement and instead rely on head rotation. Additionally, the opening angle of the foveated region should be wider so eye movement on a small scale is still without consequence for the perceived image quality. The resolution of peripheral areas may not be reduced as much as with so-called \textit{true} foveated rendering so even when the user briefly looks at such an area, the perceived loss is not as distracting. This compromised form of the technique is commonly called Fixed Foveated Rendering, for example available on Oculus Go (\autoref{fig:Oculus_FFR}). \\
Given eye tracking of some adequate sort is available, true foveated rendering can be performed in which in each frame the current focus position of each eye is queried and the virtual view matrix adjusted accordingly. This makes the rendering setup more complex as the high pixel density area can shift to any location within the image but it allows for a tighter foveal angle and lower peripheral resolution as it is much less likely - if not entirely impossible due to limits or occasional mistakes by the tracker - for the user to focus on any such low density frame data. See ZeroLight Limited's \gls{Nvidia VRS} based approach in \autoref{fig:ZeroLight_DFR}. 

\begin{figure}[H]
  \centering
     \subfloat[Oculus Go Fixed Foveated Rendering map (colored tiles decrease in resolution outward) (from \cite{Palandri.2018}, R. Palandri et al., 2018)\label{fig:Oculus_FFR}]{%
       \includegraphics[width=0.7\textwidth]{pictures/Oculus_Go_FFR}
     }
     \hfill
     \subfloat[Dynamic Foveated Rendering using Nvidia Variable Rate Shading on HTC Vive Pro Eye (from \cite{ZeroLightLimited.2019}, 2019)\label{fig:ZeroLight_DFR}]{%
       \includegraphics[width=0.7\textwidth]{pictures/ZeroLight_DFR}
     }
     \caption{Foveated rendering examples}
     \label{fig:FovRendering}
\end{figure}

\subsection{Radial Density Mask}
A somewhat related technique is called radial density masking as shown by Valve's Alex Vlachos in his talk at GDC 2016 \cite{Vlachos.2016c}. The goal is the same as with foveated rendering but the approach is different to better exploit traditional GPU architectures. Instead of reducing the theoretical rendering resolution of the peripheral ring, a mask is overlaid. The mask has the render pipeline skip a certain pattern of pixels in that ring. This can either be done by marking a checkerboard pattern of pixels in the stencil buffer so the pixel shader fails the stencil test on them - coming back to \autoref{stencilmask} - to get a pixel perfect mask, or by overlaying a masking mesh right at the near plane of the render volume so the respective fragments are discarded during early Z tests. The latter would allow to approximately match a relative area reduction target but may not be pixel perfect depending on internal frame resolution. The resulting checkerboard area can then be interpolated and filtered to reconstruct the missing information. Vlachos claims gains of up to 15\% for the Valve Aperture Robot Repair demo scene, but warns that reconstruction cost needs to be kept lower than mask savings. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{pictures/vlachos_RDM}
  \caption{Radial Density Masking (2x2 px checkerboard) (from \cite{Vlachos.2016c}, p. 22, A. Vlachos. 2016)} \label{fig:vlachos_RDM}
\end{figure} 

\subsubsection{Adaptive resolution}
The described methods of fixed/true foveated rendering and radial density masking can be combined further with another - by now almost universally used - optimization compromise: dynamic resolution scaling. While monitoring GPU load or frametimes and framepacing, the resolution of not just the central fovea but the peripheral regions too can be reduced or increased within given bounds. This can stabilize performance at the cost of some visual quality in the outer regions or - at the other end of the spectrum - alleviate some of the quality reduction if the available power overhead allows. 

\subsection{Relevancy of GPU architecture}
The previous sections describe various methods but the choice which of them is ideal for a given engine depends a lot on the target hardware. Foveated rendering relies on splitting the frame into several rectangular sub-frames and rendering them at differing internal resolution. Thus, it is only suited for GPU architectures supporting or better yet being built as so-called tile based renderers. Tile based GPUs such as Qualcomm's Adreno line and most other low power mobile SoCs compute the frame parallely in a number of set tiles. On the other hand traditional GPUs execute render commands only on a frame as one entire unit, called immediate-mode rendering, albeit with possibly many more compute units at once. These tile based architectures naturally make it very simple to render tiles outside the foveal center at lower resolution without additional overhead, with the fovea circle being better approximated the higher the tile count is. \\
Older, traditional architectures like those found in many Nvidia and AMD desktop graphics chipsets are rarely built as tile renderers and may only support this tiling in software. Recent architectures starting with Nvidia's Maxwell and AMD's Graphics Core Next 1.0 support a hybrid form of tile based rendering, for example Maxwell still uses an immediate-mode pipeline but uses a tile-based rasterizer buffering 16x16 or 32x32 pixel tiles to improve cache locality and overall shading efficiency\cite{Kanter.2016}. Graphics APIs can abstract these into more easily exploitable form. Such low-level optimized and accelerated solutions exist in Vulkan and DirectX12 alike, most notably Nvidia's Multi-Res Shading\cite{NvidiaCorporation.2016} and AMD's LiquidVR MultiRes\cite{Gallagher.2016}. On those, rendering frame regions at different resolutions requires internally splitting a frame into multiple viewports with a subsequent composition pass. This sequential process incurs additional overhead as it requires broadcasting geometry information to all these viewports, which is not possible in an efficient way on all GPU architectures as it relies on similar functionality as multiview (\autoref{MV_Stereo}) except with significantly more target viewports. The radial density mask approach may be more suitable for such traditional GPUs as it manages to render multiple resolutions within a single render pass by leveraging fragment discard features. This masking will necessitate an interpolation pass to blend away the masked pixels, while foveated rendering can technically skip further interpolation. Filtering the low resolution perifoveal pixels is recommended to reduce aliasing. 

\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\textwidth]{pictures/Nvidia_TileImmediate}
  \caption{Traditional immediate-mode rendering versus tile-based rendering at Nvidia GDC 2017 Editors Day presentation (cropped, from \cite{.08.02.2020}, A. Ngo, 2017)} \label{fig:blob}
\end{figure}